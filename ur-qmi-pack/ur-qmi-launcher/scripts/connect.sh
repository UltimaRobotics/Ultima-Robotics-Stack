#!/bin/bash

# Enhanced QMI Modem Connection Script with Optional DHCP
# Usage: sudo ./connect.sh <device> <apn> [<ip_type>] [<auth_type>] [<use_dhcp>]

# Check root
[ "$(id -u)" -ne 0 ] && { echo "Run as root with sudo"; exit 1; }

# Arguments
[ $# -lt 2 ] && {
    echo "Usage: $0 <device> <apn> [<ip_type>] [<auth_type>] [<use_dhcp>]"
    echo "IP types: 4=IPv4, 6=IPv6, 10=IPv4v6 (default: 4)"
    echo "Auth types: none, pap, chap, auto (default: none)"
    echo "DHCP: 1 to enable DHCP, 0 to use manual config (default: 0)"
    exit 1
}

# Config
DEVICE=$1
APN=$2
IPTYPE=${3:-4}
AUTH=${4:-none}
USE_DHCP=${5:-0}
WWAN_IF="wwan0"
TIMEOUT=15
RETRIES=3

# Subnet to CIDR
mask2cidr() {
    local mask=$1
    local x bits=0
    IFS=.
    for x in $mask; do
        case $x in
            255) bits=$((bits+8));;
            254) bits=$((bits+7));;
            252) bits=$((bits+6));;
            248) bits=$((bits+5));;
            240) bits=$((bits+4));;
            224) bits=$((bits+3));;
            192) bits=$((bits+2));;
            128) bits=$((bits+1));;
            0);;
            *) echo "Invalid mask: $mask"; return 1;;
        esac
    done
    echo $bits
}

# Validate gateway
validate_gateway() {
    local gw=$1
    local ip=$2
    local mask=$3
    
    # Simple validation - gateway should be in the same subnet
    IFS=. read -r i1 i2 i3 i4 <<< "$ip"
    IFS=. read -r m1 m2 m3 m4 <<< "$mask"
    IFS=. read -r g1 g2 g3 g4 <<< "$gw"
    
    [ $((i1 & m1)) -eq $((g1 & m1)) ] && \
    [ $((i2 & m2)) -eq $((g2 & m2)) ] && \
    [ $((i3 & m3)) -eq $((g3 & m3)) ] && \
    [ $((i4 & m4)) -eq $((g4 & m4)) ] || {
        echo "Gateway $gw is not in the same subnet as IP $ip with mask $mask"
        return 1
    }
}

# Manual network configuration
setup_network_manual() {
    local ip=$1 mask=$2 gw=$3 dns1=$4 dns2=$5 mtu=$6
    
    # Convert mask to CIDR
    local cidr=$(mask2cidr "$mask") || {
        echo "Invalid subnet mask: $mask"
        return 1
    }
    
    # Configure interface
    ip link set dev "$WWAN_IF" down
    ip addr flush dev "$WWAN_IF"
    ip link set dev "$WWAN_IF" mtu "$mtu"
    ip addr add "$ip/$cidr" dev "$WWAN_IF" || {
        echo "Failed to set IP"
        return 1
    }
    ip link set dev "$WWAN_IF" up
    
    # Validate and add gateway if provided
    if [ -n "$gw" ]; then
        validate_gateway "$gw" "$ip" "$mask" && {
            ip route add default via "$gw" dev "$WWAN_IF" metric 100 || {
                echo "Warning: Failed to add default route"
            }
        }
    fi
    
    # DNS
    echo "# Generated by connect.sh (manual)" > /etc/resolv.conf
    [ -n "$dns1" ] && echo "nameserver $dns1" >> /etc/resolv.conf
    [ -n "$dns2" ] && echo "nameserver $dns2" >> /etc/resolv.conf
    
    # IPv6
    [ "$IPTYPE" -ne 6 ] && [ "$IPTYPE" -ne 10 ] && \
        sysctl -w net.ipv6.conf."$WWAN_IF".disable_ipv6=1 >/dev/null
}

# DHCP network configuration
setup_network_dhcp() {
    # Configure interface
    ip link set dev "$WWAN_IF" down
    ip addr flush dev "$WWAN_IF"
    ip link set dev "$WWAN_IF" up
    
    # Run DHCP client
    echo "Starting DHCP client..."
    dhclient -v "$WWAN_IF" || {
        echo "DHCP failed, falling back to manual config"
        return 1
    }
    
    echo "# Generated by connect.sh (DHCP)" > /etc/resolv.conf
    grep 'domain-name-servers' /var/lib/dhcp/dhclient.leases | \
        awk '{print $3}' | tr ',' '\n' | sed 's/;//' | \
        while read dns; do echo "nameserver $dns" >> /etc/resolv.conf; done
    
    # IPv6
    [ "$IPTYPE" -ne 6 ] && [ "$IPTYPE" -ne 10 ] && \
        sysctl -w net.ipv6.conf."$WWAN_IF".disable_ipv6=1 >/dev/null
}

# Main
echo "Setting up QMI modem on $DEVICE with APN $APN"
echo "Using DHCP: $([ "$USE_DHCP" -eq 1 ] && echo "Yes" || echo "No")"

# Stop ModemManager
systemctl stop ModemManager 2>/dev/null

# Initialize modem
qmicli -d "$DEVICE" --dms-set-operating-mode='online' || {
    echo "Failed to set modem online"; exit 1
}

qmicli -d "$DEVICE" --wds-reset || {
    echo "Failed to reset WDS"; exit 1
}

# Bring interface up
ip link set "$WWAN_IF" down 2>/dev/null
ip link set "$WWAN_IF" up || {
    echo "Failed to bring up $WWAN_IF"; exit 1
}

# Connect
attempt=0
while [ $attempt -lt $RETRIES ]; do
    attempt=$((attempt+1))
    echo "Connection attempt $attempt/$RETRIES"
    
    CID=$(qmicli -d "$DEVICE" --device-open-net='net-raw-ip|net-no-qos-header' \
          --wds-start-network="apn='$APN',ip-type=$IPTYPE,auth=$AUTH" \
          --client-no-release-cid | grep CID: | awk '{print $2}')
    
    [ -n "$CID" ] && break
    sleep 2
done

[ -z "$CID" ] && { echo "Failed to connect"; exit 1; }
echo "Connected with CID $CID"

# Get settings
CONN_INFO=$(qmicli -d "$DEVICE" --wds-get-current-settings)
[ -z "$CONN_INFO" ] && { echo "Failed to get settings"; exit 1; }

# Extract settings
IP=$(echo "$CONN_INFO" | awk '/IPv4 address:/ {print $3}')
MASK=$(echo "$CONN_INFO" | awk '/IPv4 subnet mask:/ {print $4}')
GW=$(echo "$CONN_INFO" | awk '/IPv4 gateway address:/ {print $4}')
DNS1=$(echo "$CONN_INFO" | awk '/IPv4 primary DNS:/ {print $4}')
DNS2=$(echo "$CONN_INFO" | awk '/IPv4 secondary DNS:/ {print $4}')
MTU=$(echo "$CONN_INFO" | awk '/MTU:/ {print $2}')

# Configure network
if [ "$USE_DHCP" -eq 1 ]; then
    setup_network_dhcp || {
        echo "Falling back to manual configuration"
        setup_network_manual "$IP" "$MASK" "$GW" "$DNS1" "$DNS2" "$MTU" || {
            echo "Network setup failed"; exit 1
        }
    }
else
    setup_network_manual "$IP" "$MASK" "$GW" "$DNS1" "$DNS2" "$MTU" || {
        echo "Network setup failed"; exit 1
    }
fi

# Verify
echo "Connection established:"
ip addr show dev "$WWAN_IF"
echo "Routing table:"
ip route
echo "DNS servers:"
cat /etc/resolv.conf

# Cleanup on exit
cleanup() {
    echo "Disconnecting..."
    [ "$USE_DHCP" -eq 1 ] && dhclient -r "$WWAN_IF" 2>/dev/null
    ip addr flush dev "$WWAN_IF" 2>/dev/null
    ip route flush dev "$WWAN_IF" 2>/dev/null
    [ -n "$CID" ] && qmicli -d "$DEVICE" --wds-stop-network="$CID" --client-cid="$CID" >/dev/null 2>&1
    ip link set "$WWAN_IF" down 2>/dev/null
    systemctl start ModemManager 2>/dev/null
    exit 0
}

trap cleanup EXIT INT TERM

echo "Press Ctrl+C to disconnect"
while true; do sleep 3600; done
